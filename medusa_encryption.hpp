/**
 * Â© 2025 D Hargreaves AKA Roylepython | All Rights Reserved
 * 
 * MEDUSA_ENCRYPTION HEADER v0.3.0c
 * Generated by LAMIA Conditional Compiler
 * Yorkshire Champion Standards - NO SHORTCUTS
 */

#ifndef MEDUSA_ENCRYPTION_HPP
#define MEDUSA_ENCRYPTION_HPP

#include <string>
#include <memory>
#include <vector>
#include <array>

namespace medusa_libs {
namespace encryption {

class MedusaEncryption {
public:
    MedusaEncryption();
    ~MedusaEncryption();
    
    // Core encryption functionality - Yorkshire Champion military grade
    std::string encrypt_aes256(const std::string& plaintext, const std::string& key);
    std::string decrypt_aes256(const std::string& ciphertext, const std::string& key);
    
    // Advanced encryption methods - Discombobulator compatible
    std::string encrypt_triforce(const std::string& data, const std::string& master_key);
    std::string decrypt_triforce(const std::string& encrypted_data, const std::string& master_key);
    
    // Key management - Yorkshire Champion standards
    std::string generate_secure_key(int length = 32);
    std::string derive_key_pbkdf2(const std::string& password, const std::string& salt, int iterations = 100000);
    std::array<uint8_t, 32> generate_salt();
    
    // Hashing functions - Military grade
    std::string hash_sha256(const std::string& data);
    std::string hash_sha512(const std::string& data);
    std::string hash_blake2b(const std::string& data);
    
    // Performance optimization methods
    void optimize_for_performance();
    void optimize_for_memory();
    double get_performance_multiplier() const;
    
    // Yorkshire Champion methods
    bool initialize();
    void shutdown();
    bool is_healthy() const;
    void benchmark_performance();

private:
    bool m_initialized;
    double m_performance_multiplier;
    size_t m_memory_usage;
    std::vector<uint8_t> m_secure_buffer;
    
    // Internal optimization methods - Ground up philosophy
    void apply_compiler_optimizations();
    void setup_memory_management();
    void configure_cpu_optimizations();
    void secure_memory_wipe();
    bool validate_key_strength(const std::string& key);
};

// C interface for dynamic loading - Discombobulator ready
extern "C" {
    void* create_medusa_encryption_instance();
    void destroy_medusa_encryption_instance(void* instance);
    int initialize_medusa_encryption(void* instance);
    
    char* encrypt_aes256_c(void* instance, const char* plaintext, const char* key);
    char* decrypt_aes256_c(void* instance, const char* ciphertext, const char* key);
    char* encrypt_triforce_c(void* instance, const char* data, const char* master_key);
    char* decrypt_triforce_c(void* instance, const char* encrypted_data, const char* master_key);
    
    char* generate_secure_key_c(void* instance, int length);
    char* derive_key_pbkdf2_c(void* instance, const char* password, const char* salt, int iterations);
    char* hash_sha256_c(void* instance, const char* data);
    char* hash_sha512_c(void* instance, const char* data);
    
    bool validate_library();
}

} // namespace encryption
} // namespace medusa_libs

#endif // MEDUSA_ENCRYPTION_HPP